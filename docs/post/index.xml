<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on カタモトの/dev/null</title>
    <link>https://katamotokosuke.github.io/blog/post/</link>
    <description>Recent content in Posts on カタモトの/dev/null</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 03 Feb 2019 22:07:02 +0900</lastBuildDate>
    
	<atom:link href="https://katamotokosuke.github.io/blog/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JSON Web Tokenを完全に理解する</title>
      <link>https://katamotokosuke.github.io/blog/post/jwt/</link>
      <pubDate>Sun, 03 Feb 2019 22:07:02 +0900</pubDate>
      
      <guid>https://katamotokosuke.github.io/blog/post/jwt/</guid>
      <description>JSON Web Tokenとは ざっくり言うと「2者間で安全にクレームを表現するための方式」です。RFC7519で技術仕様の標準化が行われています。JSON Web Token(以下JWT)は大きく分けて3つの属性に分割できます。ヘッダー、ペイロード、署名の3つです。ペイロードには実際に2者間(クライアント・サーバー間と考えると分かりやすいかもしれません)で受け渡しがしたいJSONが入り、ヘッダー、署名を使って改ざんの検証に用いられます。
まだぼんやりしていて分かりにくいですが、各属性がどのようなものなのかもう少し具体的に見ていくことにします。その後、実際にどのように使っていくかを見ると理解はしやすくなります。
ヘッダー属性 ヘッダーにはどのようなアルゴリズムを用いて署名を行っているかやトークンのタイプの2つで構成されています。
例：
{ &amp;#34;alg&amp;#34;: &amp;#34;RS256&amp;#34;, &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34; } この文字列をbase64urlエンコードしたものがJWTのヘッダーとなります。プログラムっぽく書くならばこんな感じです。
header = base64url_encode(&amp;#39;{&amp;#34;alg&amp;#34;:&amp;#34;RS256&amp;#34;,&amp;#34;typ&amp;#34;:&amp;#34;JWT&amp;#34;}&amp;#39;) ヘッダーに関しては以上です。とても単純な仕様ですね。
ペイロード 実際に2者間で受け渡ししたい実体の入る属性です。要領はヘッダーと同じです。 例：
{ &amp;#34;exp&amp;#34;: &amp;#34;1550905975&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;k_k_hogetaro&amp;#34;, &amp;#34;is_engineer&amp;#34;: true } ヘッダーと同じくペイロードもbase64urlエンコードしたものとなります。 ヘッダーと違う点を挙げるとするといくつか予約語が定義されています。上の例であるとexpは仕様で定められた予約のkeyとなります。その他の予約語は仕様書を参照してみてください。
署名 ペイロード属性はbase64urlエンコードされているだけですので、このままだとデコードすれば中身を確認でき、改変できてしまいます。それだと困る場合がいろいろあります。例えばCookieの値とか。そこで署名を行い、改変の有無を検証可能なものにします。 ハッシュアルゴリズムHS256のケースを例とします。他のアルゴリズムのケースも後述します。 HS256は共通の秘密鍵で署名、検証を行います。
プログラムのように書くと以下のようになります。
value = header + &amp;#34;.&amp;#34; + payload + &amp;#34;.&amp;#34; # base64urlエンコード済みのヘッダーとペイロードを「.」で繋いだ形のものを用います。 signature = hash256(value, secret_key); これが署名のすべてです。
JWTの完成形 これでJWTのすべてが揃いました。ヘッダー、ペイロード、そして署名です。これらを「.」で繋いだものがJWTとなります。
JWT = &amp;#34;#{header}.#{payload}.#{signature}&amp;#34; JWTの使われ方 ↑まででJWTの具体的な形を見てきました。しかし、まだどのように使われるかが全くわかりません。なので、実際にどのような使われ方があるのか見ていきます。
アルゴリズムHS256の場合 署名のところでもHS256は扱いましたが、共通の鍵を用いて署名と検証を行います。なので、以下のようなケースが想定されます。あくまで一例です。
1, まず、どのサービスにでもあるようなログインを行います。利用可能ユーザーであればJWTを返却します 2, ユーザーはJWTを用いてサービスのAPIにアクセスします。 となります。2の検証ですが、署名部は秘密鍵を保有しているコンピューターにしか生成できません。そしてヘッダー、ペイロードが改変されていると、その署名と食い違いが発生するので、改変がわかる仕組みになっています。例えば次のJWTが発行されたとします。
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDJ9.UqRu8fGnUAmn-Z_wwsgGVNTXANkIiDdEbj-BdZRafks $ echo eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 | base64 -d {&amp;quot;alg&amp;quot;:&amp;quot;HS256&amp;quot;,&amp;quot;typ&amp;quot;:&amp;quot;JWT&amp;quot;} $ echo eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDJ9 | base64 -d {&amp;quot;sub&amp;quot;:&amp;quot;1234567890&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;,&amp;quot;iat&amp;quot;:151623902} もしペイロードを</description>
    </item>
    
    <item>
      <title>さよならQiita、こんにちはhugo × github pages</title>
      <link>https://katamotokosuke.github.io/blog/post/good-bye-qiita/</link>
      <pubDate>Sun, 03 Feb 2019 22:03:59 +0900</pubDate>
      
      <guid>https://katamotokosuke.github.io/blog/post/good-bye-qiita/</guid>
      <description>対象  Qiitaから脱したい Qiitaにはエモ記事が書けないので、そういった記事を独自のブログの方に書きたい  hugoとは https://gohugo.io/
Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again. Hugoは人気のあるオープンソースの静的サイトジェネレータの1つである。 半端ないスピードと柔軟性で、Hugoは再びウェブサイトの構築を楽しくするぜ。
と公式HPには書いてあります。
インストール プラットフォームによってインストール方法が異なります。 Mac
$ brew install hugo Win choco
$ choco install hugo -confirm Win scoop
$ scoop install hugo Linux snap
$ snap install hugo などなど、、、。さまざまなPFに対応しています。 https://gohugo.io/getting-started/installing
さっそくブログを作ってみる 雛形作成 雛形を作成するために以下のコマンドを実行します。
$ hugo new site site-demo &amp;amp;&amp;amp; cd site-demo なにやら生成されたようです</description>
    </item>
    
    <item>
      <title>mysql 5.6~でのalter tableでやらかさない</title>
      <link>https://katamotokosuke.github.io/blog/post/mysql-alter-table/</link>
      <pubDate>Wed, 26 Dec 2018 22:05:25 +0900</pubDate>
      
      <guid>https://katamotokosuke.github.io/blog/post/mysql-alter-table/</guid>
      <description>はじめに mysql5.6の話をします。それ以上のバージョンでも通じる話ではあると思います。 どんなシステムでも本番稼働中にindexを貼りたい、テーブル定義(カラム名、型、並び順&amp;hellip;etc)の変更をしたいことは往々してあると思います。そんな時はalter tableコマンドを叩きたい気分になります。安直にコマンドをぶっ叩くとやらかしてしまう可能性があります。今後もやらかさないためにまとめておきます。
環境 mysql&amp;gt; status; -------------- mysql Ver 14.14 Distrib 5.6.42, for Linux (x86_64) using EditLine wrapper Connection id:	3 Current database:	Current user:	root@localhost SSL:	Not in use Current pager:	stdout Using outfile:	&#39;&#39; Using delimiter:	; Server version:	5.6.42 MySQL Community Server (GPL) Protocol version:	10 Connection:	Localhost via UNIX socket Server characterset:	latin1 Db characterset:	latin1 Client characterset:	latin1 Conn. characterset:	latin1 UNIX socket:	/var/run/mysqld/mysqld.sock Uptime:	2 min 34 sec Threads: 2 Questions: 10 Slow queries: 0 Opens: 67 Flush tables: 1 Open tables: 60 Queries per second avg: 0.</description>
    </item>
    
    <item>
      <title>Railsのautoload_pathsでの定数探索</title>
      <link>https://katamotokosuke.github.io/blog/post/rails-autoload_path/</link>
      <pubDate>Tue, 25 Dec 2018 23:42:59 +0900</pubDate>
      
      <guid>https://katamotokosuke.github.io/blog/post/rails-autoload_path/</guid>
      <description>環境  Ruby 2.5.1 Rails 5.2.0  autoload_pathsの概要 例:
class Hoge &amp;lt; SuperHoge; end のようにモデルを定義したとします。Hogeは未定義の場合定数作成され、定義済みであればオープンクラスされるためautoload_pathsの出番なしですが、SuperHogeのほうが未定義だった場合autoload_pathsを元に定数を探索しに行きます。 autoload_pathsがあるので
require &amp;#39;super_hoge&amp;#39; といちいち書かなくてもよくなっています。
puts ActiveSupport::Dependencies.autoload_paths RAILS_ROOT/app/assets RAILS_ROOT/app/channels RAILS_ROOT/app/controllers RAILS_ROOT/app/controllers/concerns RAILS_ROOT/app/helpers RAILS_ROOT/app/jobs RAILS_ROOT/app/mailers RAILS_ROOT/app/models RAILS_ROOT/app/models/concerns ...etc みたいにActiveSupport::Dependencies.autoload_pathsの結果が探索の対象になります。 詳しくはwebで(https://railsguides.jp/autoloading_and_reloading_constants.html)
実際のソースコードを見てみる rubyにはさまざまなフックメソッドが提供されていてその一つに定数が見つからないときにModule#const_missingというものがあります。これをActiveSupport::Dependencies::ModuleConstMissingではオーバーライドしています。このmoduleはrubyのModuleにincludeされているのでRailsを使う際に定数が見つからないとこのメソッドのconst_missingが呼ばれることになります。なのでこれを見ていくことにします。
https://github.com/rails/rails/blob/5-2-0/activesupport/lib/active_support/dependencies.rb#L191
def const_missing(const_name) from_mod = anonymous? ? guess_for_anonymous(const_name) : self Dependencies.load_missing_constant(from_mod, const_name) end from_modはどの名前空間に属するかを特定しています。そして定数探索の旅が始まる！
ActiveSupport::Dependencies#load_missing_constant https://github.com/rails/rails/blob/master/activesupport/lib/active_support/dependencies.rb#L489
2018/05/23時点のソースをのせる。
def load_missing_constant(from_mod, const_name) unless qualified_const_defined?(from_mod.name) &amp;amp;&amp;amp; Inflector.constantize(from_mod.name).equal?(from_mod) raise ArgumentError, &amp;#34;A copy of #{from_mod}has been removed from the module tree but is still active!</description>
    </item>
    
  </channel>
</rss>